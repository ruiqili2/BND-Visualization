exp(2.4-1.2*x)/(1+exp(2.4-1.2*x))
px = function(x){
exp(2.4-1.2*x)/(1+exp(2.4-1.2*x))
}
px(2.5)
px(1)
1-px(2.5)
shiny::runApp('zoe/bism')
runApp('zoe/bism')
runApp('zoe/bism')
runApp('zoe/hh')
x
runApp('zoe/bism')
knitr::opts_chunk$set(echo = TRUE)
par(frow(c(2,2)))
par(mfrow(c(2,2)))
plot(m1)
par(mfrow = c(2,2))
plot(m1)
shiny::runApp('zoe/test')
library(mixtools)  #for ellipse
install.packages('mixtools')
library(mixtools)  #for ellipse
N <- 200 # Number of random samples
set.seed(123)
# Target parameters for univariate normal distributions
rho <- -0.6
mu1 <- 1; s1 <- 2
mu2 <- 1; s2 <- 8
# Parameters for bivariate normal distribution
mu <- c(mu1,mu2) # Mean
sigma <- matrix(c(s1^2, s1*s2*rho, s1*s2*rho, s2^2),
2) # Covariance matrix
# Function to draw ellipse for bivariate normal data
ellipse_bvn <- function(bvn, alpha){
Xbar <- apply(bvn,2,mean)
S <- cov(bvn)
ellipse(Xbar, S, alpha = alpha, col="red")
}
bvn1 <- mvrnorm(N, mu = mu, Sigma = sigma ) # from MASS package
colnames(bvn1) <- c("bvn1_X1","bvn1_X2")
source('~/.active-rstudio-document', echo=TRUE)
ellipse_bvn(mu1, 0.5)
ellipse_bvn(mu1, 3)
source('~/.active-rstudio-document', echo=TRUE)
install.packages('mvtnorm')
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
?outer
persp(x1,
x2,
z,
main="Two dimensional Normal Distribution",
sub = expression(
italic(f)~(bold(x))==frac(1,2~pi~sqrt(sigma[11]~sigma[22]~(1-rh
o^2)))~phantom(0)^bold(.)~exp~bgroup("{",
list(-frac(1,2(
1-rho^2)),
bgroup("[",
frac((x[1]~-~mu
[1])^2, sigma[11])~-~2
~rho~frac(x[1]~-~mu[1],
sqrt(sigma[11])
)~ frac(x[2]~-~mu[
2],sqrt(sigma[22]))~+~
frac((x[2]~-~mu
[2])^2, sigma[22]),"]"
)),"}")),
col="lightgreen
",
theta=30,
phi=20,
r=50,
d=0.1,
expand=0.5,
ltheta=90,
lphi=180,
shade=0.75,
ticktype="detai
led",
nticks=5)
persp(x1,
x2,
z,
main="Two dimensional Normal Distribution",
sub = expression(
italic(f)~(bold(x))==frac(1,2~pi~sqrt(sigma[11]~sigma[22]~(1-rh
o^2)))~phantom(0)^bold(.)~exp~bgroup("{",list(-frac(1,2(1-rho^2)),
bgroup("[",frac((x[1]~-~mu[1])^2, sigma[11])~-~2~rho~frac(x[1]~-~mu[1],
sqrt(sigma[11]))~ frac(x[2]~-~mu[2],sqrt(sigma[22]))~+~frac((x[2]~-~mu[2])^2, sigma[22]),"]")),"}")),
col="lightgreen",
theta=30,
phi=20,
r=50,
d=0.1,
expand=0.5,
ltheta=90,
lphi=180,
shade=0.75,
ticktype="detai
led",
nticks=5)
z = outer(x1, x2, bvnd)
persp(x1,
x2,
z,
main="Two dimensional Normal Distribution",
col="lightgreen",
theta=30,
phi=20,
r=50,
d=0.1,
expand=0.5,
ltheta=90,
lphi=180,
shade=0.75,
ticktype="detai
led",
nticks=5
)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
runApp('zoe/bism')
runApp('zoe/bism')
runApp('zoe/bism')
runApp('zoe/bism')
source('~/.active-rstudio-document', echo=TRUE)
runApp('zoe/bism')
x1  = seq(-20, 20, length = 40)
x1
x1  = seq(-20, 20, length = 41)
x1
x1  = seq(-20, 20, length = 41)
runApp('zoe/bism')
?persp
source('~/zoe/bism/bvdn_3d.R', echo=TRUE)
runApp('zoe/bism')
runApp('zoe/bism')
runApp('zoe/bism')
install.packages('rggobi')
source('~/.active-rstudio-document', echo=TRUE)
install.packages('plotly')
source('~/.active-rstudio-document', echo=TRUE)
warning()
kd <- with(MASS::geyser, MASS::kde2d(duration, waiting, n = 50))
p <- plot_ly(x = kd$x, y = kd$y, z = kd$z) %>% add_surface()
# Create a shareable link to your chart
# Set up API credentials: https://plot.ly/r/getting-started
chart_link = plotly_POST(p, filename="surface/2")
chart_link
source('~/.active-rstudio-document', echo=TRUE)
z
persp3d(x1,
x2,
z,
main="Two dimensional Normal Distribution",
col="darkorange",
theta=30,
phi=20,
r=100,
d=0.1,
expand=0.5,
ltheta=90,
lphi=180,
shade=0.75,
ticktype="detailed",
nticks=5
)
install.packages('rgl')
persp3d(x1,
x2,
z,
main="Two dimensional Normal Distribution",
col="darkorange",
theta=30,
phi=20,
r=100,
d=0.1,
expand=0.5,
ltheta=90,
lphi=180,
shade=0.75,
ticktype="detailed",
nticks=5
)
persp.im(x1,
x2,
z,
main="Two dimensional Normal Distribution",
col="darkorange",
theta=30,
phi=20,
r=100,
d=0.1,
expand=0.5,
ltheta=90,
lphi=180,
shade=0.75,
ticktype="detailed",
nticks=5
)
source('~/.active-rstudio-document', echo=TRUE)
runApp('zoe/bism')
runApp('zoe/bism')
runApp('zoe/BVD-Visualization')
output$bvndPlot <- renderPlotly({
mu1 = input$mu1
mu2 = input$mu2
s11 = input$s11
s22 = input$s22
s12 = input$s12
x1  = seq(-20, 20, length = 41)
x2 = x1
bvnd = function(x1, x2) {
term1<-1 / (2 * pi * sqrt(s11 * s22 * (1 - rho ^ 2)))
term2<--1 / (2*(1 - rho ^ 2))
term3<-(x1 - mu1) ^ 2 / s11
term4<-(x2 - mu2) ^ 2 / s22
term5<--2 * rho * ((x1 - mu1) * (x2 - mu2)) / (sqrt(s11) * sqrt(s22))
term1 * exp(term2 * (term3 + term4 - term5))
}
z = outer(x1, x2, bvnd)
plot_ly(x = x1, y = x2, z = z) %>% add_surface()
# persp(x1,
#       x2,
#       z,
#       main = "Bivariate Normal Distribution",
#       col = "darkorange",
#       ylim = c(-20, 20),
#       zlim = c(0, 0.025),
#       theta = 45,
#       phi = 20,
#       r = 50,
#       d = 0.1,
#       expand = 0.5,
#       ltheta = 90,
#       lphi = 180,
#       shade = 0.75,
#       ticktype = "detailed",
#       nticks = 5
# )
})
runApp('zoe/BVD-Visualization')
runApp('zoe/BVD-Visualization')
runApp('zoe/BVD-Visualization')
runApp('zoe/BVD-Visualization')
runApp('zoe/BVD-Visualization')
runApp('zoe/BVND-Visualization')
k = seq(1, 101, 2)
k
k = seq(1, 101, 2)
for i in k {
i = 0
for i in k {
for i in k {
i
for (i in k) {
i
}
print(i)
for (i in k) {
print(i)
}
?knn.cv
??knn.cv
for (i in k) {
knn.cv(wisc_trn, cl, k = i)
}
library(class)
library(caret)
library(class)
wisc_trn = read.csv("wisc-trn.csv")
wisc_tst = read.csv("wisc-tst.csv")
set.seed(1337)
k = seq(1, 101, 2)
for (i in k) {
knn.cv(wisc_trn, cl, k = i)
}
View(wisc_trn)
knn.cv(wisc_trn, wisc_trn$class, k = i)
knn.cv(wisc_trn, wisc_trn$Class, k = i)
knn.cv(wisc_trn, wisc_trn$class, k = i)
model = req(0, len(k))
model = req(0, length(k))
model
req(0, 2)
req(0, 03)
req(0, 10, 2
)
model = rep(0, length(k))
model
for (i in k) {
model[idx] = knn(train = trn_X, test = trn_X, cl = trn_y, k = i)
idx = idx + 1
}
library(caret)
library(class)
wisc_trn = read.csv("wisc-trn.csv")
wisc_tst = read.csv("wisc-tst.csv")
set.seed(1337)
k = seq(1, 101, 2)
calc_class_err = function(actual, predicted) {
mean(actual != predicted)
}
get_err_knn = function(train_X, test_X, train_y, test_y, k) {
pred = knn(train = train_X, test = test_X, cl = train_y, k = k)
act = test_y
calc_class_err(act, pred)
}
trn_X = wisc_trn[, -1]
tst_X = wisc_tst[, -1]
trn_y = wisc_trn$class
tst_y = wisc_tst$class
idx = 1
model = rep(0, length(k))
for (i in k) {
model[idx] = knn(train = trn_X, test = trn_X, cl = trn_y, k = i)
idx = idx + 1
}
folds = caret::createFolds(trn_y, k = 5)
folds
runApp('zoe/BVND-Visualization')
wisc_knn = train(
class ~ .,
data = wisc_trn,
method = "knn",
trControl = trainControl(method = "cv", number = 5),
tuneGrid = expand.grid(k = seq(1, 101, by = 2))
)
library(e1071)
wisc_trn = read.csv("wisc-trn.csv")
wisc_tst = read.csv("wisc-tst.csv")
k = seq(1, 101, 2)
wisc_knn
library(caret)
library(class)
library(e1071)
install.packages('e1071')
plot(wisc_knn)
?preProcess()
wisc_knn_scaled = train(
class ~ .,
data = wisc_trn,
method = "knn",
trControl = trainControl(method = "cv", number = 5),
preProcess = c("center", "scale"),
tuneGrid = expand.grid(k = seq(1, 101, by = 2))
)
wisc_knn_scaled = train(
class ~ .,
data = wisc_trn,
method = "knn",
trControl = trainControl(method = "cv", number = 5),
preProcess = c("center", "scale"),
tuneGrid = expand.grid(k = seq(1, 101, by = 2))
)
plot(wisc_knn_scaled)
?scale
getModelInfo(cforest)
getModelInfo('cforest)
getModelInfo('cforest')
getModelInfo('cforest')
wisc_knn_scaled = train(
class ~ .,
data = wisc_trn,
method = "rf",
trControl = trainControl(method = "cv", number = 5),
tuneGrid = expand.grid(mtry = seq(1, 10, by = 1))
)
wisc_knn_scaled = train(
class ~ .,
data = wisc_trn,
method = "rf",
trControl = trainControl(method = "cv", number = 5),
tuneGrid = expand.grid(mtry = seq(1, 10, by = 1))
)
set.seed(1337)
accy = wisc_rf$Accuracy
list(wisc_rf)
wisc_rf = train(
class ~ .,
data = wisc_trn,
method = "rf",
trControl = trainControl(method = "cv", number = 5),
tuneGrid = expand.grid(mtry = seq(1, 10, by = 1))
)
wisc_rf = train(
class ~ .,
data = wisc_trn,
method = "rf",
trControl = trainControl(method = "cv", number = 5),
tuneGrid = expand.grid(mtry = seq(1, 10, by = 1))
)
list(wisc_rf)
wisc_rf[1]
wisc_rf[3]
wisc_rf[5]
wisc_rf[6]
wisc_rf['mtry']
wisc_rf[4]
mtry = wisc_rf[4][1]
mtry = wisc_rf[4][1]
accy = wisc_rf[4][2]
accy
accy = wisc_rf[4][, 2]
wisc_rf[4]
wisc_rf[[4]]
mtry = wisc_rf[[4]]$mtry
accy = wisc_rf][4]]$Accuracy
accy = wisc_rf[[4]]$Accuracy
plot(wisc_rf)
wisc_knn[[4]]
wisc_knn = train(
class ~ .,
data = wisc_trn,
method = "knn",
trControl = trainControl(method = "cv", number = 5),
tuneGrid = expand.grid(k = seq(1, 101, by = 2))
)
wisc_knn = train(
)
wisc_knn = train(
class ~ .,
data = wisc_trn,
method = "knn",
trControl = trainControl(method = "cv", number = 5),
tuneGrid = expand.grid(k = seq(1, 101, by = 2))
)
wisc_knn[[4]]
wisc_knn[[4]][1][which.max(wisc_knn[[4]][2])]
which.max(wisc_knn[[4]][2])
wisc_knn[[4]][2]
which.max(as.vector(wisc_knn[[4]][2]))
class(wisc_knn[[4]][2])
which.max(as.vector(wisc_knn[[4]][2][, 1]))
wisc_knn
wisc_knn[[8]]
wisc_knn[[6]]
wisc_knn[[6]][, 1]
predict(wisc_knn, newdata = wisc_tst)
calc_acc(actual = wisc_tst$class,
predicted = predict(wisc_knn, newdata = wisc_tst))
calc_acc = function(actual, predicted) {
mean(actual == predicted)
}
calc_acc(actual = wisc_tst$class,
predicted = predict(wisc_knn, newdata = wisc_tst))
calc_acc(actual = wisc_tst$class,
predicted = predict(wisc_knn_scaled, newdata = wisc_tst))
wisc_rf
calc_acc(actual = wisc_tst$class,
predicted = predict(wisc_rf, newdata = wisc_tst[10, -1]))
wisc_tst[10, ]
wisc_tst[10, -1]
train_tab = table(predicted = wisc_rf, actual = wisc_tst$class)
wisc_rf_pred = ifelse(predict(wisc_rf, type = "link") > 0, "M", "B")
wisc_rf_pred = ifelse(predict(wisc_rf, type = "link") > 0, M, B)
wisc_rf_pred = ifelse(predict(wisc_rf, type = "prob") > 0, M, B)
wisc_rf_pred = ifelse(predict(wisc_rf) > 0, M, B)
wisc_rf_pred = ifelse(predict(wisc_rf, type = "link") > 0, M, B)
wisc_rf_pred = predict(wisc_rf)
train_tab = table(predicted = wisc_rf_pred, actual = wisc_tst$class)
wisc_rf_pred = predict(wisc_rf)
train_tab = table(predicted = wisc_rf_pred, actual = wisc_tst$class)
train_tab = table(predicted =  predict(wisc_rf,  newdata= wisc_tst), actual = wisc_tst$class)
train_tab = table(predicted =  predict(wisc_rf,  newdata= wisc_tst), actual = wisc_tst$class)
train_con_mat = confusionMatrix(train_tab, positive = "M")
c(train_con_mat$overall["Accuracy"],
train_con_mat$byClass["Sensitivity"],
train_con_mat$byClass["Specificity"])
calc_err(predicted = wisc_knn$pred, actual = wisn_trn$class)
calc_acc(predicted = wisc_knn$pred, actual = wisn_trn$class)
```{r}
calc_acc = function(actual, predicted) {
mean(actual == predicted)
}
calc_acc(predicted = wisc_knn$pred, actual = wisn_trn$class)
calc_acc(predicted = wisc_knn$pred, actual = wisc_trn$class)
wisc_knn$pred
calc_acc(predicted = predict(wisc_knn, newdata = wisc_trn), actual = wisc_trn$class)
calc_acc(predicted = predict(wisc_knn_scaled, newdata = wisc_trn), actual = wisc_trn$class)
wisc_rf$bestTune
eq(1, 10, by = 1)
seq(1, 10, by = 1)
seq(1, 10)
source('~/.active-rstudio-document', echo=TRUE)
qf(0.95, df1, df2)
F
SSR
?Qf
?qf
F = MSE1 / MSE2
source('~/.active-rstudio-document', echo=TRUE)
x
contour(x.points,y.points,z)
x
x.points <- seq(-3,3,length.out=100)
x.points
z
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
runApp('zoe/BVND-Visualization')
